from unittest import mock
import functools

from metafunctions.tests.util import BaseTestCase
from metafunctions.api import store, recall, node, bind_call_state
from metafunctions.util import highlight_current_function, traceback_from_call_state
from metafunctions.core import SimpleFunction, CallState


class TestUnit(BaseTestCase):
    def test_highlight_current_function(self):
        fmt_index = 6

        @node
        def ff(x):
            return x + 'F'

        @node
        @bind_call_state
        def f(call_state, x):
            if len(call_state._called_functions) == fmt_index:
                location_string = highlight_current_function(call_state, use_color=False)
                location_string_color = highlight_current_function(call_state, use_color=True)
                self.assertEqual(location_string, '(a | b | ff | f | f | ->f<- | f | f)')
                self.assertEqual(location_string_color,
                        '(a | b | ff | f | f | \x1b[31m->f<-\x1b[0m | f | f)')
                self.assertEqual(x, '_abFff')
            return x + 'f'

        pipe = a | b | ff | f | f | f | f | f
        pipe('_')

        state = CallState()
        af = a + f
        af('_', call_state=state)
        curr_f = highlight_current_function(state, use_color=False)
        self.assertEqual(curr_f, '(a + ->f<-)')

    @mock.patch('metafunctions.util.highlight_current_function')
    def test_highlight_current_function_multichar(self, mock_h):
        mock_h.side_effect = functools.partial(highlight_current_function, use_color=False)
        # Don't fail on long named functions. This is a regression test
        @node
        def fail(x):
            if not x:
                1 / 0
            return x - 1

        cmp = fail | fail + a

        with self.assertRaises(ZeroDivisionError) as e:
            cmp(1)
        self.assertTrue(e.exception.args[0].endswith('(fail | (->fail<- + a))'))

    def test_highlight_with_map(self):
        self.fail('todo')

    @mock.patch('metafunctions.util.highlight_current_function')
    def test_add_location_from_call_state(self, mock_h):
        mock_h.side_effect = functools.partial(highlight_current_function, use_color=False)
        # raise_with_call_state is a context manager that catches any exception generated by the
        # metafunction, and raises it with location information from the provided call_state
        @node
        def fail(x):
            1 / 0

        cmp = a + b | c & fail & fail

        with traceback_from_call_state() as state:
            with self.assertRaises(ZeroDivisionError) as e:
                cmp('x', call_state=state)
        self.assertEqual(str(e.exception),
                'division by zero \n\nOccured in the following function: ((a + b) | (c & ->fail<- & fail))')
        self.fail('todo')

@node
def a(x):
    return x + 'a'
@node()
def b(x):
    return x + 'b'
@node()
def c(x):
    return x + 'c'
